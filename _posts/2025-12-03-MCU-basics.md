---
layout: single
title:  "신입사원에게 들려주는 - MCU SW 직무 기초 개념완성"
typora-root-url: ../
---

### 임베디드 MCU 개요

* 오늘날의 자동차 부품 대부분은 전자화 되어있으며 SW에 의해 조작 → SW를 실행하는 컴퓨터가 필요  
* 자동차 업계에서 그 컴퓨터 역할을 하는 하드웨어를 **제어기** 또는 **ECU**라고 함  
* 이러한 제어기는 각 차량 장치마다 각각 존재하며 케이스에 패키징되어 자동차에 내장되어있음
* ECU(제어기) 안에 실제 SW가 실행, 동작하는 **작은 크기의 컴퓨터**를 **MCU(Micro Controller Unit)** 라고함   
* MCU는 CPU, 램을 비롯한 다양한 하드웨어 장치로 구성  
* 제어기는 MCU와 제어기가 동작하기 위해서 필요한 부수적인 부품이 보드에 구성되어 자동차에 **내장(Embedded)되**어있음

### 임베디드 SW 특징  
1. 각자의 제품을 컨트롤 하기 위한 동작만을 반복해서 수행하고 있음 (cf. 가정용 PC)  
→ PC보다 일반적으로 낮은 성능의 CPU, 작은 크기의 메모리 탑재
3. 제한된 성능 조건에서 필요한 기능 모두 수행되도록 SW 구현 필요
4. SW 개발환경(PC)과, 실제 실행되는 환경(MCU)이 다름     
→ PC에서 개발된 SW를 MCU로 옮기는 과정필요
→ 디버깅이 어려워 별도 디버깅을 위한 장비(디버거) 필요

### 임베디드 MCU SW 일반적 구조  
* Input (센서, 버튼, 통신) → Processing (SW 로직) → Output (모터, LCD화면, 메시지 송신)

### MCU SW 개요
* MCU를 구성하는 CPU는 사람이 작성한 소스 코드(C, C++, Python 등)를 직접 이해하고 명령을 수행할 수 없음
* 사람이 작성한 **소스 코드(.c)** 를 CPU가 이해할 수 있는 **어셈블리어, 기계어(.hex,.elf)** 로 변환하는 과정이 필요함  
→ 이 과정을 **빌드(컴파일)** 라고하며 이를 **컴파일러** 가 수행함. 즉 컴파일러는 빌드를 수행하는 SW임  
※ 빌드는 엄밀히 Compile(r), Assemble(r), Link(er)로 구성되어있지만 빌드 해주는 SW를 통칭 컴파일러로 부름  
→ MCU의 CPU는 소스 코드를 그대로 실행을 하는것이 아닌 변환된 기계어가 담겨진 .hex, .elf 파일의 명령어를 한줄 한줄 해석하고 수행함
* ATmega128, STM32 등 다양한 MCU가 존재하며, MCU에 따라 이해할 수 있는 기계어 명령어의 형태가 다름  
→  이를 지원하는 컴파일러 역시 여러 종류가 존재하며, 사용하는 MCU를 지원하는 컴파일러를 선택하여 사용해야함
* 소스 코드와 컴파일을 통해 말들어진 .hex, .elf 파일은 모두 개발자의 PC의 하드디스크 또는 SSD 저장장치에 파일 형태로 남아있음  
→  MCU는 명령을 수행하는 CPU뿐 아니라 데이터를 담아두는 플래시 메모리와 RAM으로 구성되며 CPU는 이들 메모리에 있는 데이터를 읽고 쓸 수 있음  
→  컴파일된 .hex,.elf 파일을 MCU의 **플래시 메모리** 에 옮기기 위한 과정이 필요하며 이를 위한 하드웨어 장비를 **디버거** 라고 부름   
→  디버거의 종류에는 **Trace32(T32), TI의 XDS110, ST의 ST-Link** 등이 있으며 MCU의 특정핀과 연결되어 디버깅을 위한 여러가지 기능 및 SW 다운로드 기능 제공하고 이를 제어하기 위해 (전용) 디버깅 SW 필요  
→  본인이 개발하려는 MCU와 호환되는 컴파일러 SW, 디버거 HW, 디버깅 SW 선택 필요  
※ 플래시 메모리는 전원을 껐다 켜도 데이터가 유지되지만, RAM은 전원을 끄면 저장된 내용이 모두 사라지는 일시적 메모리

### IDE 개요
* 코딩 → 빌드 → 다운로드/디버깅 전체 작업을 하나의 프로그램에서 수행할 수 있도록 구성된 개발 환경을 **IDE (Integrated Development Environment-통합 개발 환경)** 라고 함
* IDE에는 코드 에디터, 컴파일러, 디버깅 SW가 모두 포함되며 보통 MCU 제조사에서 무료로 제공 (디버거는 별도 구매 필요)
* 대표적인 MCU 제조사-IDE 이름-(대표 MCU 예시) : **Microchip-Microchip Studio-(ATmega128), ST-STM32 Cube IDE-(STM32|4s5vit6), TI-Code Composer Studio(CCS)-(TMS320F280039C), Infineon-Aurix Development Studio, NXP-MUCXpresso**   
※ IDE에서 신규 프로젝트 생성 (사용하는 Target MCU 지정하여 생성)  
※ 새롭게 생성된 프로젝트에는 선택된 MCU에 알맞게 여러가지 컴파일러 셋팅이 자동으로 적용되어있음  
→ MCU에 맞는 Default Setting을 써도 되지만 Complier, Assembler, Linker에 대한 configuration 변경도 가능  
※ 프로젝트를 빌드 (이떄, 사용자가 구현한 코드 외에 startup code도 함께 빌드됨)  
→ MCU의 전원을 키면 바로 Main 함수가 실행되는게 아니라 초기화 작업을 거치게됨. hex 파일안에는 메인 함수에 대한 기계어가 들어있을 뿐 아니라 초기화 작업을 해주는 Startup Code도 hex 파일 앞부분에 위치. IDE가 설치된 폴더 안에 별도의 Startup 코드가 존재하여(.o) 코드 빌드시 메인함수와 빌드되어 생성 (협업에서 default를 사용하지 않고 사용자가 startup 코드를 별도로 만들어야하는 경우도 있음)  
※ Debug 폴더에 .hex, .elf 파일이 생성됨  
※ MCU 플래시 메모리로 .hex, .elf 파일을 다운받기 위해서 IDE에서 어떤 디버거 및 (통신)인터페이스를 사용할지 셋팅이 필요함
※ 디버거가 연결이 되어있는 상태에서는 CPU가 코드를 실행하지 않고 멈춰있음 (디버킹 및 검증 작업 수행). 사용자가 디버거를 통해서 신호를 주면 그때부터 코드 실행. 디버거 연결 해제 후 재부팅시 코드 정상 실행
※ 디버깅 작업에는 Start/일지 정지/Stop, 변수값 확인(단 실시간 업데이트는 안됨, 디버거따라 다름), 변수값 변경, Break Point 기능 등이 있음