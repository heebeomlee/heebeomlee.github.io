---
layout: single
title: "CAN(Controller Area Network) 기초개념 PART2"
---

### CAN 통신의 에러와 신뢰성 확보 메커니즘

### 1. **CAN 통신과 신뢰성의 중요성**

- **자동차 부품의 신뢰성**: 차량 부품의 오작동은 생명과 직결될 수 있으므로, **통신의 신뢰성**이 매우 중요.
- CAN 통신은 **고장 감지** 및 **대응 메커니즘**을 프로토콜에 정의하여 높은 신뢰성을 보장.
    - 에러 감지 후 동작 방식.
    - 에러가 반복될 경우의 처리 방식.

---

### 2. **CAN 통신에서 고장(에러)의 예시**

- **보내는 쪽**에서 발생할 수 있는 에러:
    - 데이터를 `1`로 보내야 하는데 **잘못** `0`으로 보냄.
    - 데이터 포맷(ID, DLC, 데이터 등)을 **벗어난 메시지**를 보냄.
- **받는 쪽**에서 발생할 수 있는 에러:
    - 보낸 데이터 `1`을 `0`으로 잘못 해석.
    - 데이터 포맷을 잘못 해석.

---

### 3. **에러 처리 메커니즘**

- CAN 프로토콜은 에러를 감지하고 이에 따른 동작을 정의:
    - 에러의 종류를 감지.
    - 에러 발생 시 동작 정의.
    - 반복된 에러 발생 시 추가적인 대응책.

---

### 4. **에러 방지를 위한 CAN 통신의 설계**

- **물리 계층 설계**:
    - **CAN HIGH**와 **CAN LOW** 두 신호선을 사용.
    - 데이터 표현 방식:
        - `0`: CAN HIGH(3.75V), CAN LOW(1.25V).
        - `1`: CAN HIGH(2.5V), CAN LOW(2.5V).
    - *전압차(Differential Voltage)**를 이용하여 데이터 표현.
        - 노이즈가 발생해도 두 선에 동일한 영향을 주기 때문에 전압차로 정확한 데이터 판별 가능.
    - 예:
        - 노이즈가 추가되어 전압이 올라가도 전압차는 유지 → 데이터 왜곡 방지.

---

### 5. **에러 감지와 하드웨어 역할**

- 에러가 발생하더라도 CAN 컨트롤러의 **하드웨어적인 처리**로 에러 감지 가능.
- 감지되는 에러의 종류:
    - CAN 컨트롤러가 자동으로 감지.
    - 별도의 소프트웨어 구현 필요 없음.

---

### 6. **중요성과 우선순위**

- 감지되는 에러의 종류를 모두 이해하지 않아도 작업에는 큰 지장 없음.
- CAN 컨트롤러가 하드웨어적으로 에러를 처리하므로, **기본 원리**만 이해해도 충분.
- 에러의 세부 종류는 이후 설명 예정.

---

### 7. **결론**

- CAN 통신은 신뢰성 높은 설계를 통해 노이즈와 에러에 강한 통신을 보장.
- 에러 발생 시 CAN 컨트롤러가 자동으로 감지하고, 프로토콜에 정의된 메커니즘에 따라 대응.
- 시스템 신뢰성을 위해 물리적 설계와 프로토콜 정의가 긴밀히 연계되어 있음.
- 

---

### **CAN 프로토콜의 3가지 에러 상태**

1. **에러 액티브 (Error Active)**
    - **특징**: 네트워크에서 적극적으로 에러를 감지하고 보고하는 상태.
    - **동작**:
        - 에러 감지 시 `TEC`(Transmit Error Counter) 또는 `REC`(Receive Error Counter)를 증가시킴.
        - **액티브 에러 프레임** 전송: 네트워크 전체에 강력히 알림.
        - 액티브 에러 프레임은 **6개의 도미넌트 비트**를 포함하여 비트 스터핑 규칙을 의도적으로 어기며, 이를 통해 네트워크가 에러를 확실히 인식하게 함.
2. **에러 패시브 (Error Passive)**
    - **특징**: 에러 발생 횟수가 많아져 통신 참여 우선순위가 낮아진 상태.
    - **동작**:
        - 에러 감지 시 여전히 `TEC` 또는 `REC`를 증가시키지만, **패시브 에러 프레임** 전송: 에러 알림의 강도가 약함.
        - 패시브 에러 프레임은 네트워크의 다른 메시지에 의해 덮일 수 있어 에러 알림 효과가 제한됨.
        - 메시지 송신 시 우선순위가 낮아지며, 대기 시간을 추가로 가짐.
3. **버스 오프 (Bus Off)**
    - **특징**: 통신에서 완전히 배제된 상태.
    - **동작**:
        - `TEC`이 255를 초과할 경우 버스 오프 상태로 전환.
        - 메시지 송신 및 수신이 불가능.
        - **복귀 조건**: 버스에서 긴 시간 동안 아무도 메시지를 송신하지 않을 때(리셉티브 상태)만 복귀 가능하며, 이를 위해 CAN 컨트롤러를 리셋하거나 별도 조건을 충족시켜야 함.

---

### **에러 카운터 관리**

- **TEC**: 송신 중 에러를 감지하면 증가.
- **REC**: 수신 중 에러를 감지하면 증가.
- 정상적인 통신 시 카운터 감소.
- 상태 전환 기준:
    - **에러 액티브 → 에러 패시브**: TEC 또는 REC ≥ 128.
    - **에러 패시브 → 버스 오프**: TEC ≥ 255.

---

### **비트 스터핑 룰**

- **정의**: 동일한 비트가 **6개 이상 연속**으로 버스에 출력될 수 없음.
- CAN 컨트롤러는 5개의 동일 비트를 전송한 후 **강제로 반대 비트**를 삽입.
- 수신자는 이 삽입된 비트를 무시하고 데이터를 복원.
- **의도적인 비트 스터핑 위반**: 액티브 에러 프레임에서 6개의 도미넌트 비트를 강제로 전송하여 네트워크에 에러 발생을 알림.

---

### **에러 프레임의 차이**

- **액티브 에러 프레임**:
    - 6개의 도미넌트 비트를 강제로 삽입하여 네트워크 전체가 에러를 인식하게 함.
- **패시브 에러 프레임**:
    - 연속된 리세시브 비트를 송신하며, 다른 메시지에 의해 알림 효과가 줄어들 수 있음.

---

### **실무에서 중요한 포인트**

- **버스 오프 상태 관리**:CAN 컨트롤러가 스스로 에러를 감지하고 상태를 전환하지만, **버스 오프 상태**에서는 CPU가 통신 복구를 담당해야 함.
- **대응 로직**:
    - 버스 오프 발생 시 CAN 컨트롤러를 리셋하거나 조건에 따라 통신에 재참여하도록 설정.
    - 예: 고장 원인을 진단하고 네트워크를 복구하기 위한 추가 로직 구현.

---

이 내용은 CAN 프로토콜에서 에러 상태 관리와 네트워크 안정성을 확보하기 위한 핵심적인 설계를 잘 설명하고 있습니다. 추가적인 질문이 있다면 말씀해주세요!

---

이 영상의 내용을 요약하면 다음과 같습니다. CAN(Controller Area Network) 프로토콜의 에러 메커니즘과 주요 에러 유형, 특히 **비트 에러**, **스텁 에러**, **CRC 에러**, **Acknowledge 에러** 등에 대한 설명입니다. CAN 통신은 높은 신뢰성과 효율성을 요구하며, 이를 위해 다음과 같은 방법으로 에러를 처리합니다.

---

### 1. **비트 에러 (Bit Error)**

- **개념**: CAN 컨트롤러는 송신자가 전송한 비트를 다시 읽어 실제 전송값과 비교하여 에러 여부를 판단합니다.
    - 예: 1을 보냈는데 0이 수신되거나, 0을 보냈는데 1이 수신된 경우.
- **예외**: Arbitration(중재) 과정에서는 비트 에러가 아닌 정상 동작으로 간주됩니다.
    - 예를 들어, 우선순위가 낮은 메시지를 보내던 제어기가 우선순위가 높은 메시지를 감지하면 자신이 보낸 값(1)을 다시 읽었을 때 0으로 나타날 수 있지만, 이는 에러로 처리되지 않습니다.

---

### 2. **스텁 에러 (Stuff Error)**

- **개념**: CAN 통신에서는 같은 비트가 6번 연속으로 버스에 나타나면 에러로 간주합니다.
    - 이는 버스의 신호 동기화를 유지하기 위해 삽입되는 "스텁 비트(Stuff Bits)" 규칙 때문입니다.
- **기준**: 전압 레벨 기준으로 판단하며, 실제 데이터 값이 아닌 버스 출력 신호를 기준으로 합니다.

---

### 3. **CRC 에러 (Cyclic Redundancy Check Error)**

- **역할**: 데이터를 수신한 후 데이터 변조 여부를 확인하는 코드로, 데이터와 함께 전송됩니다.
    - 송신자는 데이터를 기반으로 CRC 코드를 생성하여 메시지 끝에 포함시켜 전송합니다.
    - 수신자는 받은 데이터와 CRC 값을 통해 연산을 수행하여 데이터 변조 여부를 판단합니다.
- **체크섬과의 비교**: 체크섬은 단순한 덧셈 방식으로 에러 검출 능력이 낮지만, CRC는 나눗셈 기반으로 더 높은 정확도로 데이터 변조를 감지합니다.
- **에러 처리**:
    - 수신자가 CRC 연산 결과에서 문제를 감지하면 이를 송신자에게 알립니다.

---

### 4. **Acknowledge 에러**

- **메커니즘**: 송신자는 Acknowledge 슬롯 비트(ACK)를 1로 채워 전송하고, 수신자는 데이터가 정상임을 확인한 후 0으로 응답합니다.
    - 송신자가 1을 썼는데 다시 읽었을 때 0이라면, 이는 메시지가 정상적으로 수신되었음을 의미합니다.
    - 수신자가 아무도 없거나 모두 CRC를 문제로 판단하면 ACK는 1로 유지되며, 송신자는 이를 에러로 간주합니다.
- **에러 예외 상황**:
    - 버스에 수신자가 없으면 송신자는 CRC 에러로 잘못 판단할 수 있지만, 이후 메커니즘을 통해 이를 감지하고 에러로 처리하지 않습니다.

---

### 5. **에러 검출 후 동작**

- 송신자는 에러를 감지하면 **에러 프레임**을 전송하여 네트워크 상태를 알립니다.
- **수신자 모드**로 전환하거나, 데이터 재전송 등의 과정을 통해 시스템의 안정성을 유지합니다.

---

이 내용은 CAN 프로토콜이 높은 신뢰성을 유지하기 위해 설계된 에러 검출 및 처리 메커니즘을 잘 설명하고 있습니다. 추가적으로 궁금한 부분이나 더 자세히 알고 싶은 항목이 있다면 알려주세요!

---

### AURIX MCU의 CAN 컨트롤러 에러 처리

### 1. **CAN 컨트롤러와 에러 처리 개요**

- AURIX MCU에는 **CAN 컨트롤러**가 내장되어 있으며, 이는 하드웨어적으로 에러를 처리할 수 있는 **에러 핸들링 유닛(Error Handling Unit)**을 포함.
- CAN 프로토콜의 에러 처리 규정을 그대로 구현하여 동작.
- 이 에러 핸들링 유닛은 CAN 통신 중 발생하는 폴트(fault)를 감지하고 관리.

---

### 2. **에러 핸들링 구성 요소**

- **REC(Receive Error Counter)**: 수신 에러를 추적하는 카운터.
- **TEC(Transmit Error Counter)**: 송신 에러를 추적하는 카운터.
- **비트스트리머 프로세서(Bit Stream Processor)**:
    - 에러를 스스로 감지.
    - 감지한 에러에 따라 REC와 TEC 카운터 값을 증가시킴.

---

### 3. **CAN 컨트롤러의 에러 상태**

- **Error States**:
    - **Active State**: 정상적인 동작 상태에서 에러 감지.
    - **Passive State**: 에러가 증가하여 활성 상태에서 비활성 상태로 전환.
    - **Bus-Off State**: 에러가 심각해져 버스에서 분리되는 상태.
- CAN 컨트롤러가 에러 상태에 따라 동작을 자동으로 관리.

---

### 4. **레지스터를 통한 상태 확인**

- CAN 컨트롤러의 **레지스터**를 통해 현재 상태를 모니터링 가능.
    - **TEC/REC 값 확인**: 레지스터에서 송수신 에러 카운터 값을 직접 읽을 수 있음.
    - **Bus-Off 상태 확인**: 레지스터 내 특정 비트필드를 통해 확인.
        - 비트 값이 `1`이면 Bus-Off 상태임.
        - CPU는 주기적으로 상태를 읽어 동작을 제어 가능.

---

### 5. **Bus-Off 상태 처리**

- Bus-Off 상태에서의 처리 방식:
    1. **소프트웨어 구현**:
        - CPU가 상태를 읽어 Bus-Off 상태(`1`)인지 확인 후 동작 처리.
    2. **인터럽트 방식**:
        - Bus-Off 상태가 발생하면 인터럽트를 발생시켜 소프트웨어에 알림.

---

### 6. **결론**

- AURIX MCU의 CAN 컨트롤러는 하드웨어적으로 CAN 프로토콜의 에러 처리 기능을 완벽히 구현.
- 소프트웨어는 상태 모니터링 및 인터럽트 설정을 통해 에러에 따른 동작을 정의하면 됨.
- MCU에 내장된 기능을 활용하여 간단히 에러 관리 가능.